# toio位置制御 実装技術レポート

本プロジェクトにおける「座標指定による自律移動機能」の実装詳細と、開発中に遭遇した課題・解決策をまとめます。

## 1. 機能概要
Unityアプリケーションからtoio（実機）を制御し、特定のマット座標へ自律移動させる機能を実装しました。

*   **ターゲット**: 開発用マット (TMD01SS-A) 上の特定のtoio
*   **機能**: スペースキー押下でマット中央（250, 250）へ移動
*   **特徴**: 複数台のtoioが稼働している環境でも、マット上にある個体を自動識別して接続

## 2. 実装クラス: `ToioPositionController`

### 主なフロー
1.  **初期化 (`Start`)**: `CubeManager` を介してtoioに接続。
2.  **個体識別ロジック**: 複数接続を行い、座標データが有効な（マットに乗っている）個体を選定。
3.  **移動命令 (`Update`)**: 入力トリガーにより `TargetMove` コマンドを発行。
4.  **フィードバック**: `targetMoveCallback` により到着・エラー判定。

## 3. 遭遇した技術的課題と解決策

### 課題A: 座標情報が更新されない (0, 0 のまま)
初期実装では、接続しても `cube.x`, `cube.y` が `0` のままで更新されず、移動命令が即座に `ToioIDmissed` (認識不能) エラーとなっていました。

*   **原因**: 一部の環境・ファームウェアでは、デフォルトでID通知（座標通知）がOFFになっているか、頻度が低い設定になっている可能性があります。
*   **解決策**: 接続直後に明示的に `ConfigIDNotification` を呼び出し、通知を有効化しました。
    ```csharp
    // 500ms四方、変化があった時のみ通知（高頻度すぎると負荷になるためバランス調整）
    await cube.ConfigIDNotification(500, Cube.IDNotificationType.OnChanged);
    await cube.ConfigIDMissedNotification(500); // マットから外れた通知も設定
    ```

### 課題B: 意図しないtoioに接続してしまう
開発環境周辺に充電中のtoioなど（電源ON状態）が複数ある場合、`scanner.NearestScan()` (信号強度が最も強いもの) を使っても、必ずしも「目の前のマットに乗せたtoio」と繋がるとは限りませんでした。結果、マットに乗っていないtoioと接続し、座標が取れずにエラーとなっていました。

*   **解決策**: 「マルチコネクト＆フィルタリング」方式を採用しました。
    1.  `cubeManager.MultiConnect(4)` で、周囲のtoioを最大4台まで手当たり次第に接続。
    2.  全台のセンサー通知をONにする。
    3.  少し待機（データの到達待ち）。
    4.  **「座標(x, y) が (0, 0) ではない」** (= マットを認識している) toioを探す。
    5.  該当するtoioを制御対象とし、それ以外は切断する。

    ```csharp
    // ロジック抜粋
    foreach (var c in cubes) {
        if (c.x != 0 || c.y != 0) {
            targetCube = c; // これが正解のtoio
            break;
        }
    }
    ```

## 4. API使用例まとめ

| 機能 | 使用メソッド/プロパティ | 備考 |
| :--- | :--- | :--- |
| **接続** | `CubeManager.MultiConnect(int n)` | 複数接続して選別するために使用 |
| **センサー設定** | `cube.ConfigIDNotification(...)` | **必須**。これを呼ばないと座標が来ない場合がある |
| **移動** | `cube.TargetMove(...)` | 指定座標へPID制御等で自律移動 |
| **座標取得** | `cube.x`, `cube.y`, `cube.angle` | プロパティから現在の値を参照可能 |
| **イベント** | `cube.targetMoveCallback` | 移動完了(`Normal`)やロスト(`ToioIDmissed`)の判定に推奨 |

## 5. 今後の拡張性
現在の実装は「マット上の1台」を特定するロジックが入っているため、これを応用すれば「マットA上のtoio」と「マットB上のtoio」を区別してペアリングする（座標範囲で判定する）といった実装も容易に可能です。
